# Initialization

## Continuous Decision Variables

If the problem has continuous variables, the solutions can be represented as a vector of real numbers. The initial population can be generated by randomly sampling the search space. Let $\mathbf{u}$ represent the upper bound of the search space and $\mathbf{l}$ represent the lower bound. A solution can be generated by $x_d \sim U(l_d, u_d)$, where $x_d$ is the value of the $d$-th dimension of the solution and $U(l_d, u_d)$ is the uniform distribution between $l_d$ and $u_d$.

The following code shows how to initialize a population of continuous solutions in Python using NumPy. `np.random.uniform(lb, ub, (n, m))` generates a random matrix of size `n*m` with values between `lb` and `ub`. `lb` and `ub` are the lower and upper bounds of the search space, respectively.

```python
import numpy as np

def initialize_population(n, m, lb, ub):
    return np.random.uniform(lb, ub, (n, m))
```

In the following example, we initialize a population of 10 solutions with 5 continuous variables between 0 and 1.

```python
n = 10  # population size
m = 5   # number of variables
lb = 0   # lower bound
ub = 1   # upper bound
population = initialize_population(n, m, lb, ub)
print(population)
```

The output is a 2D array with 10 rows and 5 columns, where each row represents a solution. Each element in a row is a real number that represents a decision variable in the optimization problem.

```bash
[[0.69663661 0.49340243 0.02880549 0.32492558 0.80725589]
 [0.57400077 0.57905948 0.24390804 0.67556948 0.70341195]
 [0.55923604 0.13218644 0.93584815 0.31679711 0.18105029]
 [0.78836294 0.40805264 0.16752297 0.27407416 0.26316409]
 [0.08698314 0.97917866 0.02544112 0.5055591  0.50929047]
 [0.04188082 0.32957081 0.26521222 0.49283512 0.23937609]
 [0.5225056  0.36493714 0.42798761 0.88686327 0.98000543]
 [0.3230074  0.47481632 0.43179096 0.64277851 0.90340064]
 [0.20339349 0.4667067  0.41996452 0.68039768 0.4304545 ]
 [0.0359359  0.63904855 0.45470584 0.7922985  0.86746941]]
```

In addition, the initialization of the population can be biased by using the prior knowledge of the problem. For example, if the problem has a known feasible region, the initial population can be generated within the feasible region.

## Binary Decision Variables

If the problem has binary variables, the solutions can be represented as a string of 0s and 1s. The length of the string is equal to the number of decision variables. For example, if the problem has 5 binary variables, a solution can be represented as "10101". By setting the equal probability of 0 and 1 for each dimension of the solution, the initial population can be generated.

The following code shows how to initialize a population of binary solutions in Python using NumPy. `np.random.randint(0, 2, (n, m))` generates a random binary matrix of size $n \times m$.

```python
import numpy as np

def initialize_population(n, m):
    return np.random.randint(0, 2, (n, m))
```

In the following example, we initialize a population of 10 solutions with 5 binary variables.

```python
n = 10  # population size
m = 5   # number of variables
population = initialize_population(n, m)
print(population)
```

The output is a 2D array with 10 rows and 5 columns, where each row represents a solution. Each element in a row is a binary variable that represents a decision variable in the optimization problem.

```bash
[[1 0 1 0 1]
 [0 0 1 1 0]
 [0 1 0 0 1]
 [0 0 1 1 0]
 [1 0 1 0 0]
 [0 1 1 0 0]
 [1 0 0 0 1]
 [1 1 0 1 1]
 [1 0 1 1 1]
 [1 1 1 1 0]]
```

## Sequence Decision Variables

If the problem has sequence variables, the solutions can be represented as a permutation of the numbers from 1 to $n$. The initial population can be generated by randomly shuffling the numbers from 1 to $n$. The following code shows how to initialize a population of sequence solutions in Python using NumPy. `np.random.permutation(n)` generates a random permutation of the numbers from 0 to $n-1$.

```python
import numpy as np

def initialize_population(n, m):
    return np.array([np.random.permutation(n) for _ in range(m)])
```

In the following example, we initialize a population of 10 solutions with 5 sequence variables.

```python
n = 10  # population size
m = 5   # number of variables
population = initialize_population(n, m)
print(population)
```

The output is a 2D array with 5 rows and 10 columns, where each row represents a solution. Each element in a row is a number from 0 to 9, representing a decision variable in the optimization problem.

```bash
[[7 1 6 5 2 8 0 4 3 9]
 [7 8 3 4 9 1 2 0 5 6]
 [1 7 2 3 8 5 6 9 4 0]
 [3 1 6 7 4 2 9 5 0 8]
 [6 5 7 3 1 2 9 0 4 8]]
```